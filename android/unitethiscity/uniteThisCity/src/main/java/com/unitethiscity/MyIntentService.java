package com.unitethiscity;

import java.util.Random;

import com.unitethiscity.data.DataManager;
import com.unitethiscity.data.LoginManager;
import com.unitethiscity.data.UTCWebAPI;
import com.unitethiscity.general.Constants;
import com.unitethiscity.general.Logger;
import com.unitethiscity.ui.MainActivity;

import android.app.AlarmManager;
import android.app.IntentService;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.PowerManager;
import android.os.SystemClock;
import android.support.v4.app.NotificationCompat;
import android.widget.Toast;

public class MyIntentService extends IntentService {

	private static String mName = Constants.MY_INTENT_SERVICE;
	
	private static PowerManager.WakeLock sWakeLock;
    private static final Object LOCK = MyIntentService.class;
    private static final String TOKEN = Long.toBinaryString(new Random().nextLong());
    
    public MyIntentService() {
		super(mName);
	}
    
    static void runIntentInService(Context context, Intent intent) {
    	Logger.info(mName, "run intent in service");
        synchronized(LOCK) {
            if (sWakeLock == null) {
                PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
                sWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "utc_gcm_wakelock");
            }
        }
        sWakeLock.acquire();
        intent.setClassName(context, MyIntentService.class.getName());
        context.startService(intent);
    }
    
    @Override
    public final void onHandleIntent(Intent intent) {
    	Logger.info(mName, "on handle intent");
        try {
            String action = intent.getAction();
            if (action.equals("com.google.android.c2dm.intent.REGISTRATION")) {
            	Logger.info(mName, "on handle intent - registration");
                handleRegistration(intent);
            } else if (action.equals("com.google.android.c2dm.intent.RECEIVE")) {
            	Logger.info(mName, "on handle intent - receive");
                handleMessage(intent);
	        } else if (action.equals("com.example.gcm.intent.RETRY")) {
	        	Logger.info(mName, "on handle intent - retry");
	            String token = intent.getStringExtra("token");
	            // make sure intent was generated by this class, not by a malicious app
	            if (TOKEN.equals(token)) {
	            	SharedPreferences settings = getSharedPreferences(Constants.SHARED_PREFERENCES_NAME, 0);
	                String registrationId = settings.getString(Constants.GCM_REGISTRATION_ID, "");
	                if (registrationId != null) {
	                	// last operation was attempt to unregister; send UNREGISTER intent again
	                	handleRegistration(intent);
	                }
	            } else {
	                // last operation was attempt to register; send REGISTER intent again
	            	handleRegistration(intent);
	            }
	        }
        } finally {
            synchronized(LOCK) {
                sWakeLock.release();
            }
        }
    }
    
    private void handleRegistration(Intent intent) {
    	Logger.info(mName, "handle registration");
        String registrationId = intent.getStringExtra("registration_id");
        String error = intent.getStringExtra("error");
        String unregistered = intent.getStringExtra("unregistered");       
        // registration succeeded
        if (registrationId != null) {
        	Logger.info(mName, "registration ID: " + registrationId);
            // store registration ID on shared preferences
            SharedPreferences settings = getSharedPreferences(Constants.SHARED_PREFERENCES_NAME, 0);
            SharedPreferences.Editor editor = settings.edit();
            editor.putString(Constants.GCM_REGISTRATION_ID, registrationId);
            editor.putLong(Constants.GCM_EXPONENTIAL_BACKOFF, 1000);
            editor.commit();
            
            // notify 3rd-party server about the registered ID
            if(LoginManager.getInstance().userLoggedIn()) {
            	Logger.info(mName, "sending registration ID to server");
            	UTCWebAPI.createPushToken(LoginManager.getInstance().getAccountContext().getToken(),
            			0, 
            			LoginManager.getInstance().getAccountContext().getAccountID(), 
            			Constants.PUSH_TOKEN_DEVICE_ID, // device type Android - 2 
            			registrationId, 
            			true);
            }
        }
            
        // unregistration succeeded
        if (unregistered != null) {
            // get old registration ID from shared preferences and then remove it
            SharedPreferences settings = getSharedPreferences(Constants.SHARED_PREFERENCES_NAME, 0);
            String oldRegistrationId = settings.getString(Constants.GCM_REGISTRATION_ID, "");
            SharedPreferences.Editor editor = settings.edit();
            editor.remove(Constants.GCM_REGISTRATION_ID);
            editor.putLong(Constants.GCM_EXPONENTIAL_BACKOFF, 1000);
            editor.commit();
            
            // notify 3rd-party server about the unregistered ID
            if(LoginManager.getInstance().userLoggedIn()) {
            	UTCWebAPI.deletePushToken(LoginManager.getInstance().getAccountContext().getToken(),
            			LoginManager.getInstance().getAccountContext().getAccountID(), 
            			oldRegistrationId);
            	
            	DataManager.getInstance().setUnregistering(false);
            }
        } 
            
        // last operation (registration or unregistration) returned an error;
        if (error != null) {
            if ("SERVICE_NOT_AVAILABLE".equals(error)) {
            	// exponential back-off
            	SharedPreferences settings = getSharedPreferences(Constants.SHARED_PREFERENCES_NAME, 0);
            	long backoffTimeMs = settings.getLong(Constants.GCM_EXPONENTIAL_BACKOFF, 1000);
            	long nextAttempt = SystemClock.elapsedRealtime() + backoffTimeMs;
            	Intent retryIntent = new Intent("com.example.gcm.intent.RETRY");
            	retryIntent.putExtra("token", TOKEN);
            	PendingIntent retryPendingIntent = PendingIntent.getBroadcast(this, 0, retryIntent, 0);
            	AlarmManager am = (AlarmManager) this.getSystemService(Context.ALARM_SERVICE);
            	am.set(AlarmManager.ELAPSED_REALTIME, nextAttempt, retryPendingIntent);
            	backoffTimeMs *= 2; // Next retry should wait longer.
                SharedPreferences.Editor editor = settings.edit();
                editor.putLong(Constants.GCM_EXPONENTIAL_BACKOFF, backoffTimeMs);
                editor.commit();
            } 
            else if ("ACCOUNT_MISSING".equals(error)) {
            	// ask the user to set up their Google account
            	Toast.makeText(DataManager.getInstance().getMainActivityContext(),
            			"Please add a Google account to receive UTC notifications.", 
            			Toast.LENGTH_SHORT).show();
            }
            else if ("AUTHENTICATION_FAILED".equals(error)) {
            	// ask the user to fix their password
            	Toast.makeText(DataManager.getInstance().getMainActivityContext(),
            			"Please correct your Google account password to receive UTC notifications.", 
            			Toast.LENGTH_SHORT).show();
            }
            else if ("INVALID_SENDER".equals(error)) {
            	// sender account not recognized, this shouldn't occur unless the Google
            	// API project number becomes invalid
            }
            else if ("PHONE_REGISTRATION_ERORR".equals(error) || 
            		"INVALID_PARAMETERS".equals(error)) {
            	// let the user know their phone doesn't support GCM
            	Toast.makeText(DataManager.getInstance().getMainActivityContext(),
            			"Your device does not support UTC notifications.", 
            			Toast.LENGTH_SHORT).show();
            }
            else {
                // Unrecoverable error, log it
                Logger.info(mName, "Received error: " + error);
            }
        }
    }
    
    private void handleMessage(Intent intent) {
    	Logger.info(mName, "handle message");

        String alert = intent.getStringExtra("alert");
        if(alert == null) {
        	alert = "";
        }
        Logger.info(mName, "message alert - " + alert);
        String badge = intent.getStringExtra("badge");
        if(badge == null) {
        	badge = "";
        }
        Logger.info(mName, "message badge - " + badge);
        // default image resource
        int drawable = R.drawable.ic_launcher;
        // other drawables could be requested here
        if(badge.equals("1")) {
        	Logger.info(mName, "message requesting default image (launcher icon)");
        	drawable = R.drawable.ic_launcher;
        }
        // generates a system notification
		NotificationCompat.Builder builder =
		        new NotificationCompat.Builder(this)
		        .setSmallIcon(drawable)
		        .setContentTitle("Unite This City")
		        .setContentText(alert);

		// create a pending intent that will bring the app back up in 
		// the same state that it was previously
		Intent resultIntent = new Intent(this, MainActivity.class);
		resultIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
		resultIntent.setAction("com.unitethiscity.ui.MainActivity");
		resultIntent.putExtra("destFromNotify", Constants.MenuID.UTC.getValue());

		PendingIntent resultPendingIntent = PendingIntent.getActivity(
				this, 
				0, 
				resultIntent, 
				PendingIntent.FLAG_CANCEL_CURRENT);
		//PendingIntent resultPendingIntent = PendingIntent.getBroadcast(DataManager.getInstance().getMainActivityContext(), 0, resultIntent, 0);
		builder.setContentIntent(resultPendingIntent);
		builder.setAutoCancel(true);

		NotificationManager notificationManager =
			    (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		Notification thisNotification = builder.build();
		
		// use default sound and vibration settings
		thisNotification.defaults |= Notification.DEFAULT_SOUND;
		thisNotification.defaults |= Notification.DEFAULT_VIBRATE;
		
		// id allows you to update the notification later on.
		notificationManager.notify(0, thisNotification);
	}
    
}